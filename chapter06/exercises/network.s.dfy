//////////////////////////////////////////////////////////////////////////////
// Network
//////////////////////////////////////////////////////////////////////////////

// DO NOT EDIT THIS FILE! It's a trusted file that specifies how the network
// delivers packets, allowing reorder and duplicate delivery.

// Option is a common type we usually keep in our standard library.
datatype Option<V> = None | Some(value:V)

// The binding between a host step and a network step:
// if the host thinks it received na.rcv, then the network must agree
// such a packet is ready to be received at the host.
// Likewise, if the network is going to accept na.send for later delivery,
// the host had better agree it wanted to send those packets.
datatype NetAction<M> = NetAction(rcv:Option<M>, send:set<M>)

datatype NetState<M> = NetState(messageSet:set<M>)

predicate NetInit(s:NetState) {
  s.messageSet == {}
}

predicate NetNext(s:NetState, s':NetState, a:NetAction) {
  && (a.rcv.Some? ==> a.rcv.value in s.messageSet)
  && s'.messageSet == s.messageSet + a.send
  // A fancier network might constrain hosts to only send messages with correct
  // source addresses. In this exercise, you define the message structure, so
  // we're not going to enforce anything here.
}
