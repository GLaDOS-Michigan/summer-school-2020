//////////////////////////////////////////////////////////////////////////////
// DistributedSystem
//////////////////////////////////////////////////////////////////////////////

// DO NOT EDIT THIS FILE! It's a trusted file that specifies how hosts interact
// with one another over the network.

include "protocol.i.dfy"

// Before we get here, caller must define a type Message that we'll
// use to instantiate network.s.dfy.

// A global constant telling us how many hosts are participating.  It's a
// constant so we don't have to prove it doesn't change as the execution
// evolves.
function NumHosts() : nat
  ensures NumHosts() > 0

// "newtype" means that HostId is just an int ... except that it always
// satisfies 0 <= b < NumHosts().
// ("nat" is "newtype nat = b: int | 0 <= b".)
newtype HostId = b: int | 0 <= b < NumHosts()

// The set of all host identities.
function AllHosts() : set<HostId> {
  set h:HostId | true     // ignore the "No terms found" warning.
}

datatype DistState = DistState(
  hosts:map<HostId, HostState>, network:NetState<Message>)

predicate WFState(s:DistState) {
  // We don't lose track of any of the hosts.
  && s.hosts.Keys == AllHosts()
}

predicate DistInit(s:DistState) {
  && WFState(s)
  && (forall id :: HostInit(s.hosts[id], id))
  && NetInit(s.network)
}

predicate NextStep(s:DistState, s':DistState, id:HostId, a:NetAction<Message>) {
  && WFState(s)
  && WFState(s')
  && HostNext(id, s.hosts[id], s'.hosts[id], a)
  && (forall other :: other != id ==> s'.hosts[other] == s.hosts[other])
  && NetNext(s.network, s'.network, a)
}

predicate DistNext(s:DistState, s':DistState) {
  exists id, a :: NextStep(s, s', id, a)
}
